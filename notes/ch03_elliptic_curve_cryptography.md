# Elliptic Curve Cryptography

We’re going to build the primitives needed to sign and verify messages, which is at the heart of what Bitcoin does.

We can use the same point addition equations with the addition, subtraction, multiplication, division, and exponentiation as we defined them for finite fields, and everything still works. 

Because we defined an elliptic curve point and defined the +, - ,* and / operators for finite fields, we can combine the two classes to create elliptic curve points over a finite field. Being able to do the same equation but with different definitions for the basic arithmetic operators is how we construct an elliptic curve cryptography library.

## Point Addition over Finite Fields

It turns out that a “line” in a finite field is not quite what you’d expect. The equation nevertheless works, and we can calculate what y should be for a given x.

Elliptic curve point addition works over all fields! The same exact formulas we used to calculate point addition over reals work over finite fields. 

## Scalar Multiplication for Elliptic Curves

We can add a point to itself: `P1 * 2`. We call _scalar multiplication_. That is, we have a scalar number in front of the point.

One property of scalar multiplication is that it’s really hard to predict without calculating. 

Point addition is nonlinear and not easy to calculate. Performing scalar multiplication is straightforward, but doing the opposite, point division, is not.

This is called the _discrete log problem_ and is the basis of elliptic curve cryptography. This is all a bit confusing, but it’s fair to say that we could call the problem the “discrete point division” problem instead of the discrete log problem.

Another property of scalar multiplication is that at a certain multiple, we get to the point at infinity. If we imagine a point G and scalar-multiply until we get the point at infinity, we end up with a set: 

`{ G, 2G, 3G, 4G, ... nG } where nG = 0`

It turns out that this set is called a group, and because n is finite, we have a finite group (or more specifically, a finite cyclic group). 

Groups are interesting mathematically because they behave well with respect to addition:

`G + 4G = 5G or aG + bG = (a + b)G`

When we combine the fact that scalar multiplication is easy to do in one direction but hard in the other and the mathematical properties of a group, we have exactly what we need for elliptic curve cryptography.

## Scalar Multiplication Redux

Scalar multiplication is adding the same point to itself some number of times. 

The key to making scalar multiplication into public key cryptography is using the fact that scalar multiplication on elliptic curves is very hard to reverse.

Scalar multiplication looks really random, and that’s what gives this equation asym‐ metry. An asymmetric problem is one that’s easy to calculate in one direction, but hard to reverse.

## Mathmatical Groups

What we actually want to generate for the purposes of public key cryptography are finite cyclic groups, and it turns out that if we take a generator point from an elliptic curve over a finite field, we can generate a finite cyclic group.

Unlike fields, groups have only a single operation. In our case, point addition is the operation. Groups also have a few other properties, like closure, invertibility, commu‐ tativity, and associativity. Lastly, we need the identity.

## Coding Scalar Multiplication

There’s a cool technique called _binary expansion_ that allows us to perform multiplica‐ tion in log2(n) loops, which dramatically reduces the calculation time for large numbers.


impl std::ops::Mul<u32> for ECPoint {
    type Output = Self;

    fn mul(self, coefficient: u32) -> Self {
        let current = self;
        let mut result = Self::infinity(self.curve);

        for i in (0..32).rev() {
            result = result + result;

            let bit = (coefficient >> i) & 1;
            if bit == 1 {
                result = result + current;
            }
        }

        result
    }
}

This is an advanced technique. If you don’t understand bitwise operators, think of representing the coefficient in binary and only adding the point where there are 1’s. 

With __add__ and __rmul__, we can start defining some more complicated elliptic curves.

## Defining the Curve for Bitcoin

The security of elliptic curve cryptography depends on computers not being able to go through an appreciable fraction of the group.

An elliptic curve for public key cryptography is defined with the following parameters:
- We specify the a and b of the curve `y2 = x3 + ax + b`.
- We specify the prime of the finite field, `p`.
- We specify the `x` and `y` coordinates of the generator point `G`. We specify the order of the group generated by `G`, `n`.

These numbers are known publicly and together form the cryptographic curve. There are many cryptographic curves and they have different security/convenience trade- offs, but the one we’re most interested in is the one Bitcoin uses: `secp256k1`. The parameters for secp256k1 are these:

```
a = 0, b = 7, making the equation y2 = x3 + 7  

p = 2256 – 232 – 977

Gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8

n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
```

`Gx` refers to the `x` coordinate of the point `G` and `Gy` the `y` coordinate. The numbers starting with `0x` are hexadecimal numbers.

`p` is extremely close to `2^256`. This means that most numbers under `2^256` are in the prime field, and thus any point on the curve has `x` and `y` coordinates that are expressible in 256 bits each. `n` is also very close to `2^256`. This means any scalar multiple can also be expressed in 256 bits.

Third, `2^256` is a huge number. Amazingly, any number below `2^256` can be stored in 32 bytes. This means that we can store the private key relatively easily.

## Public Key Cryptography

The key operation that we need is `P = eG`, which is an asymmetric equation. We can easily compute `P` when we know `e` and `G`, but we cannot easily compute `e` when we know `P` and `G`. This is the discrete log problem described earlier. The difficulty of discrete log will be essential to understanding signing and verifica‐ tion algorithms.

Generally, we call `e` the private key and `P` the public key. Note here that the private key is a single 256-bit number and the public key is a coordinate (x,y), where x and y are each 256-bit numbers.

## Signing and Verification

We want to prove possession of the secret without revealing the secret itself. Ultimately this is going to be used in transactions, which will prove that the rightful owners of the secrets are spending the bitcoins.

### Elliptic Curve Digital Signature Algorithm (ECDSA)

The ECDSA algorithm is a way to sign a message with a private key and verify that the message was signed with the corresponding public key.

The secret in our case is `e` satisfying the following: `eG = P`, where `P` is the public key and `e` is the private key.

The target that we’re going to aim at is a random 256-bit number, `k`. We then do this: `kG = R`. `R` is now the target that we’re aiming for. In fact, we’re only going to care about the `x` coordinate of `R`, which we’ll call `r`. You may have guessed already that `r` here stands for random.

We claim at this point that the following equation is equivalent to the discrete log problem: `uG + vP = kG`, where `k` was chosen randomly, `u`,`v` `≠ 0` can be chosen by the signer, and `G` and `P` are known. This is due to the fact that: `uG + vP = kG` implies `vP = (k – u)G`. 

Since `v ≠ 0`, we can divide by the scalar multiple v: `P = ((k – u)/v)G`.

If we know `e`, we have: `eG = ((k – u)/v)G` or `e = (k – u)/v` This means that any `(u,v)` combination that satisfies the preceding equation will suffice.

If we don’t know `e`, we’ll have to play with `(u,v)` until `e = (k–u)/v`. If we could solve this with any `(u,v)` combination, that would mean we’d have solved `P = eG` while knowing only `P` and `G`. In other words, we’d have broken the discrete log problem.

This means to provide a correct `u` and `v`, we either have to break the discrete log problem or know the secret `e`. Since we assume discrete log is hard, we can say `e` is assumed to be known by the one who came up with `u` and `v`.

The _signature hash_ is incorporated into our `uG + vP` calculation this way: `u = z/s, v = r/s`, where `z` is the hash. 

We can calculate s:
`uG + vP = R = kG` 
`uG + veG = kG`
`u + ve = k`
`z/s + re/s = k`
`(z + re)/s = k`
`s = (z + re)/k`

This is the basis of the signature algorithm, and the two numbers in a signature are `r` and `s`.
Verification is straightforward: `uG + vP` where `u,v ≠ 0`
`uG + vP = (z/s)G + (re/s)G = ((z + re)/s)G = ((z + re)/((z + re)/k))G = kG = (r,y)`

## Verification in Depth
Signatures sign some fixed-length value (our “contract”)—in our case, something that’s 32 bytes. The fact that 32 bytes is 256 bits is not a coincidence, as the thing we’re signing will be a scalar for `G`.
To guarantee that the thing we’re signing is 32 bytes, we hash the document first. In Bitcoin, the hashing function is hash256, or two rounds of sha256. This guarantees the thing that we’re signing is exactly 32 bytes. We will call the result of the hash the signature hash, or `z`.
The signature that we are verifying has two components, `(r,s)`. `r` is the `x` coordinate of some point `R` that we’ll come back to. The formula for `s` is: `s = (z+re)/k`

Keep in mind that we know `e` (`P = eG`, or what we’re proving we know in the first place), we know `k` (`kG = R`), and we know `z`.
We will now construct `R = uG + vP` by defining `u` and `v` this way: `u = z/s v = r/s`

Thus:

`uG + vP = (z/s)G + (r/s)P = (z/s)G + (re/s)G = ((z + re)/s)G `

We know `s = (z + re)/k`, so:

`uG + vP = ((z + re) / ((z + re)/k))G = kG = R`

We’ve successfully chosen `u` and `v` in such a way as to generate `R` as we intended. Furthermore, we used `r` in the calculation of `v`, proving we knew what `R` would be. The only way we can know the details of `R` beforehand is if we know `e`.

To wit, here are the steps:
1. We are given `(r,s)` as the signature, `z` as the hash of the thing being signed, and `P` as the public key (or public point) of the signer.
2. We calculate `u = z/s, v = r/s`.
3. We calculate `uG + vP = R`.
4. If `R`’s `x` coordinate equals `r`, the signature is valid.

## Signing in Depth
Given that we know how verification should work, signing is straightforward. The only missing step is figuring out what `k`, and thus `R = kG`, to use. We do this by choosing a random `k`.
The signing procedure is as follows:

1. We are given `z` and know e such that `eG = P`.
2. Choose a random `k`.
3. Calculate `R = kG` and `r = x` coordinate of `R`.
4. Calculate `s = (z + re)/k`.
5. Signature is `(r,s)`.

Note that the public key (pubkey) `P` has to be transmitted to whoever wants to verify it, and `z` must be known by the verifier. We’ll see later that `z` is computed and `P` is sent along with the signature.

## Importance of a Unique k
There’s an important rule in signatures that utilize a random component like we have here: the `k` needs to be unique per signature. That is, it cannot get reused. In fact, a `k` that’s reused will result in you revealing your secret! 

To combat this, there is a deterministic k generation standard that uses the secret and z to create a unique, deterministic k every time. The specification is in RFC 6979.